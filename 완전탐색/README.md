# 완전탐색 공부 목표
- 완전탐색 개념
  - 언제 써야할지
  - 종류
- Dynamic Programming
  - 개념

---
# 완전탐색이란?
단순히 모든 경우의 수를 다 찾아서 체크하며 True or False를 가려내는 방법이다.
완전탐색의 최고의 장점은 **답은 반드시 있다.** 이다.
즉 모든 경우의 수 안에는 우리가 찾고자 하는 답이 있을 것이다.

그럼 완전탐색만 쓰지 왜 안써? 라는 의문이 들 수 있다.
하지만 우리는 지성이 있는 사람으로 두가지의 의문이 동시에 떠오를 수 있다.

- 문제를 해결하였는가?
- 효율적으로 코드가 작동 되는가?

완전탐색의 최고의 장점을 통해 우리는 문제를 해결하였다. 하지만 **효율적으로 코드가 작동되었는가?**는 생각해 봐야 할 문제이다.

예시로 100개의 요소를 가진 배열이 있는데, 우리는 100을 찾아야 한다면?
운이 좋아 배열의 첫번째에 100이 있었다면, 바로 찾을 수 있지만 배열의 가장 마지막 인덱스에 있었다면, 100번을 전부 찾아야 한다. 최악의 경우**시간복잡도 O(n)**이라고 생각할 수 있다.
하지만 문제에서 O(n) 보다 낮아야 하는 조건을 걸었다면..? 어떻게 문제를 해결해야 할까?

이를 해결하기 위해 반대로 정렬도 생각해보고, **이분 탐색 알고리즘**도 생각해 봐야 한다.

완전탐색하는 방법에는 여러 종류가 있다.
- Brute Force : 조건/반복으로 해결
- Recursive : 재귀
- 순열
- DFS/BFS
...etc


---
# Dynamic Programming
Dynamic Programming(이하 DP라 말한다.)은 Greedy Algorithm과 함께 나오는 단골 세트 메뉴이다. 이유는 시작점이 Greedy와 같은 **가장 작은 문제에서 시작**하는 것이다. 하지만 이에 파생된 방법은 다른데, DP는 **모든 경우의 수를 조합해 최적의 해를 찾는 방식** 이라는 점이다.


DP의 원리는 정답을 구한 **작은 문제를 어딘가에 메모**해 두고, 그보다 큰 문제를 풀어나갈 때 똑같은 작은 문제 방식이 나온다면 작은 문제를 구한 정답을 활용한다.
풀어 말하자면 아래와 같다.

1. 주어진 **문제를 쪼개서** 하위 문제로 나누어 푼다. 
2. **하위 문제들의 해결 방법을 결합**한다.
3. **큰 문제**에 **하위 문제의 결합을 사용**한다.


> 하나의 문제는 단 한번만 풀도록 하는 알고리즘이 DP이다

DP의 예시로는 피보나치 수열을 재귀로 만드는 구현 방법이 있다.
```js
function fibo(n) {
    if (n <= 2) return 1;
    return fibo(n - 1) + fibo(n - 2);
}
```
피보나치 수열을 보자면 n = 4라고 가정했을때,
```js
fibo(4) = fibo(3) + fibo(2)
fibo(3) = fibo(2) + fibo(1)
fibo(4) = (fibo(2) + fibo(1)) + fibo(2)
```
라고 생각할 수 있다. 즉 **큰 문제를 작은 문제로 나눌 수 있고 (fibo(3)), 작은 문제가 반복해서 일어나는 경우 fibo(2) + fibo(1) 이 계속 일어 날 것이다.**
그리고 n이 높은 값으로 증가함에 다라 구하는 방식은 계속 동일 할 것이다.

피보나치 수열을 통해 DP의 조건을 만족한다는 것을 알 수 있었다.
1. 작은 문제의 반복이 있다.
2. 작은 문제의 결과가 큰 문제를 해결하는데 여러번 사용되어야 한다.


---
## DP - Recursion + Memoization
위에 설명에서 언급했었는데, 작은 문제를 어딘가에 메모를 해둔다면 실행 횟수가 줄어 들 수 있다. 즉 효율적인 코드를 짤 수 있다.

```js
function fiboMemo (n, memo = []) {
    // 해결한 문제인가?
    if (momo[n] !== undefined) return mono[n];

    // 탈출 조건
    if (n <= 2) return 1;

    // 작은 문제 해결 후 memo의 저장
    let result = fiboMemo(n - 1, memo) + fiboMemo(n - 2, memo);
    memo[n] = result;
    return result;
}
```

위를 코드 방식을 보자면 n = 6이라 가정했을때,
```js
fiboMemo(3) = fiboMemo(2) + fiboMemo(1);
fiboMemo(4) = fiboMemo(3) + fiboMemo(2);
fiboMemo(5) = fiboMemo(4) + fiboMemo(3);
fiboMemo(6) = fiboMemo(5) + fiboMemo(4);
```
이렇게 저장된 값을 불러와 바로바로 줄 수 있다.
즉 **Memoization** 방식을 사용하지 않는다면 **O(2^n)의 시간복잡도**가 되지만, 사용한다면 
**O(n)** 까지 줄일 수 있다.


일반적인 for문 구현 방법과 Memoization 방법으로 한 실행시간 차이는 얼마나 될까?
```js
function fiboForloop(n) {
    if(n <= 2) return 1;
    let fiboArr = [0, 1, 1];
    for(let i = 3; i <= n; i++) {
        fiboArr[i] = fiboArr[i-1] + fiboArr[i-2];
    }
    return fiboArr[n];
}
```